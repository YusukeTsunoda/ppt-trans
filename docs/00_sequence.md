承知いたしました。個人開発者として、この壮大かつ高品質なプロジェクトを一人でやり遂げるための、より現実的で具体的なステップ・バイ・ステップのガイドを作成します。

一人開発の最大の敵は**「モチベーションの維持」**と**「複雑さによる混乱」**です。そのため、以下のガイドでは**「小さな成功を積み重ね、動くものを常に手元に置きながら進める」**ことを最優先します。

---

### 個人開発者のための実装ガイド：PPT Translator App

#### 始めに：心構えと準備

1.  **完璧を目指さない**: 最初からすべての機能を完璧に作ろうとすると挫折します。「まずは動く、後で綺麗にする」を徹底しましょう。
2.  **スコープを絞る**: MVP（Minimum Viable Product）のスコープをさらに絞り込みます。例えば、最初は「日本語→英語」の翻訳だけに特化するなど。
3.  **ドキュメントはあなたの相棒**: 混乱したら、必ず作成した要件定義書や設計書に戻ってください。それが道しるべになります。

---

### 【Phase -1: 開発の土台作り】（1〜2日）

**目標**: コーディングに集中できる、迷わない環境を整える。

| ステップ | 実装内容 | やること（具体的アクション） | 確認・参照すべきこと |
| :--- | :--- | :--- | :--- |
| **1. ツールセットアップ** | 外部サービスのアカウント作成 | 1. GitHubリポジトリを作成（Public or Private）。<br>2. Vercel, Supabase, Stripe, Modal, Inngest, Claude API のアカウントをすべて作成。<br>3. 各サービスのAPIキーや接続情報を一箇所（例: 1Passwordなどのパスワードマネージャー）にまとめておく。 | **参照ドキュメント**: 非機能要件書 11.3 (本番環境構成) |
| **2. ローカル開発環境** | DevContainerの構築 | 1. VSCodeに "Dev Containers" 拡張機能をインストール。<br>2. プロジェクトルートに `.devcontainer` フォルダを作成。<br>3. `devcontainer.json` と `docker-compose.yml` を設定。Docker Composeで `postgres` (Supabaseローカル版) と `inngest/dev-server` を起動するように記述。<br>4. VSCodeで `Dev: Reopen in Container` を実行し、コンテナ内でターミナルが開けることを確認。 | **参照ドキュメント**: 詳細要件書 10.2 (Docker構成), Inngest公式ドキュメント (Dev Server) |
| **3. プロジェクト構造** | Turborepoモノレポ構築 | 1. `npx create-turbo@latest` コマンドでモノレポの雛形を作成。<br>2. `apps/web` (Next.js), `packages/ui`, `packages/tsconfig` などをセットアップ。 | **参照ドキュメント**: 詳細要件書 5.1 (コンポーネント構成), Turborepo公式ドキュメント |
| **4. データ契約の定義** | Zodによる型定義 | 1. `packages/shared` ディレクトリを作成。<br>2. `index.ts` に、Zodを使って `User`, `File`, `TranslationJob` など主要なデータモデルのスキーマを定義。<br>3. このパッケージを `apps/web` からインポートできることを確認。 | **参照ドキュメント**: 機能要件書 11.1 (主要エンティティ), Zod公式ドキュメント |
| **5. DBセットアップ** | PrismaによるDBマイグレーション | 1. `packages/db` ディレクトリを作成し、Prismaをセットアップ。<br>2. `schema.prisma` にUserモデルなどを定義。<br>3. `prisma migrate dev` コマンドを実行し、ローカルのPostgreSQLにテーブルが作成されることを確認。 | **参照ドキュメント**: 詳細要件書 3.2 (テーブル定義), Prisma公式ドキュメント |

**このフェーズのゴール**: `git push` するとVercelに空のNext.jsアプリがデプロイされ、ローカルではVSCodeを開くだけで開発が始められる状態。

---

### 【Phase 0: アプリの背骨を作る】（3〜5日）

**目標**: 画面はなくても、裏側のデータの流れ（神経系）を完成させる。

| ステップ | 実装内容 | やること（具体的アクション） | 確認・参照すべきこと |
| :--- | :--- | :--- | :--- |
| **1. 認証の実装** | Supabase Authによるユーザー認証 | 1. Next.jsにSupabaseの公式ヘルパーライブラリ (`@supabase/ssr`) を導入。<br>2. ログイン/サインアップのAPIルートを作成。<br>3. 簡単なログインフォームと、ログイン後に「ようこそ、ユーザーさん」と表示されるだけの保護されたページを作成。 | **参照ドキュメント**: 機能要件書 AUTH-001/002, Supabase公式ドキュメント |
| **2. 非同期処理の骨格** | Inngestによるダミージョブ | 1. `app/api/inngest/route.ts` を作成し、Inngestの関数を定義。<br>2. 「ファイルアップロード」を模したAPIエンドポイントを作成。このAPIはInngestに `{ event: "app/translation.requested", data: { fileId: "dummy-id" } }` というイベントを送信するだけ。<br>3. Inngest関数側でこのイベントを受け取り、ログに「Step 1」「Step 2」と出力するだけのステップを実行。 | **参照ドキュメント**: Inngest公式ドキュメント (Quick Start), 詳細要件書 4.3 |
| **3. Python連携** | Modal.comとの連携 | 1. `modal init` でModalのプロジェクトを初期化。<br>2. `@modal.function()` デコレータをつけた簡単なPython関数（例: `def process(text: str): return f"Processed: {text}"`）を作成し、`modal deploy` でデプロイ。<br>3. Inngestのステップ内から、`fetch` を使ってデプロイしたModalの関数を呼び出す。Modalの認証情報をヘッダーに含めることを忘れずに。 | **参照ドキュメント**: Modal公式ドキュメント (Calling functions), 詳細要件書 4.2 |

**このフェーズのゴール**: 認証が通り、APIを叩くと裏側でInngestとModalが連携して動くことが、ログや各サービスのダッシュボードで確認できる状態。**まだUIはほとんどありませんが、システムの心臓部は完成しています。**

---

### 【Phase 1: 最初の価値を提供する（MVP）】（1〜2週間）

**目標**: ユーザーが「ファイルをアップロードして、翻訳結果を得る」というコアな体験をできる最小限の機能を完成させる。

| ステップ | 実装内容 | やること（具体的アクション） | 確認・参照すべきこと |
| :--- | :--- | :--- | :--- |
| **1. ファイル処理** | アップロードとテキスト抽出 | 1. **フロントエンド**: ドラッグ＆ドロップでファイルをアップロードするUIを作成。<br>2. **API**: アップロードされたファイルをSupabase Storageに保存し、そのファイルパスを添えてInngestにジョブを発行する。<br>3. **Python (Modal)**: `python-pptx` を使い、受け取ったファイルパスからPPTXファイルを読み込み、**全スライドのテキストを抽出してJSON形式で返す**関数を実装。<br>4. **ワーカー (Inngest)**: Pythonからの結果をDBに保存。 | **参照ドキュメント**: 機能要件書 FILE-001, python-pptx公式ドキュメント |
| **2. AI翻訳** | Claude APIの組み込み | 1. **ワーカー (Inngest)**: テキスト抽出の次のステップとして、抽出したテキストをClaude APIに送信し、翻訳結果を取得する処理を追加。<br>2. **TM/TB (レベル1 - 完全一致)**: 翻訳前にDBを検索し、ヒットしたらAPI呼び出しをスキップ。翻訳後は結果をDBに保存する。**複雑なことはせず、完全一致のみ。** | **参照ドキュメント**: Anthropic (Claude) APIドキュメント, 詳細要件書 4.3 (バッチ処理) |
| **3. 結果表示** | プレビューと編集UI | 1. **クライアントサイドプレビュー**: `pptx-js` を使って、ブラウザ上でPPTXをパース。スライドのサムネイルと、スライドごとのテキストリストを表示する。<br>2. **ツインパネル**: 右側に原文と、DBから取得した翻訳結果を表示する。**この時点ではハイライト連動は不要。**<br>3. **進捗表示**: Supabase Realtimeを使い、DBのジョブステータスの変更を検知して、UIに「処理中...」「完了」などを表示。 | **参照ドキュメント**: pptx-jsのGitHubリポジトリ, 機能要件書 EDIT-002, Supabase Realtimeドキュメント |

**このフェーズのゴール**: ユーザーが実際にファイルをアップロードし、少し待つと翻訳されたテキストが画面に表示される。**見た目は粗削りでも、アプリの核となる価値を体験できる状態。**

---

### 【Phase 2: プロダクトとして磨き上げる】（1週間〜）

**目標**: MVPを商用レベルの品質に引き上げ、収益化の仕組みを導入する。

| ステップ | 実装内容 | やること（具体的アクション） | 確認・参照すべきこと |
| :--- | :--- | :--- | :--- |
| **1. 収益化** | Stripe決済とプラン管理 | 1. 料金プランページを作成。<br>2. Stripe Checkoutへのリダイレクトと、Webhookによるプラン同期を実装。<br>3. ユーザーのプランに応じて機能制限（例: 月間翻訳ファイル数）をかける`middleware.ts`を実装。 | **参照ドキュメント**: Stripe公式ドキュメント, 機能要件書 USER-003, 非機能要件書 2.2 |
| **2. UX向上** | インタラクティブ機能の追加 | 1. `pptx-js`から取得したテキストボックスの位置情報と、DBから取得したテキストIDをマッピング。<br>2. テキストリストにマウスオーバーすると、プレビュー上の対応するボックスがハイライトされる機能を実装。<br>3. 編集内容をDBに保存する機能を実装。 | **参照ドキュメント**: 詳細要件書 5.3 (ツインパネル, ハイライト) |
| **3. 品質担保** | テストと観測性の強化 | 1. **E2Eテスト**: Cypressを使って、サインアップ→ファイルアップロード→翻訳→結果確認、という一連の流れを自動テスト化。<br>2. **エラー追跡**: Sentryを導入し、フロントエンドとバックエンドのエラーを自動で収集・通知するように設定。<br>3. **ロギング**: `console.log`だけでなく、VercelのLog Drains機能やPinoのような構造化ロガーを導入して、本番環境のログを追跡しやすくする。 | **参照ドキュメント**: Cypress, Sentry公式ドキュメント, 詳細要件書 11.1 |

**このフェーズのゴール**: ユーザーがお金を払ってでも使いたいと思える品質と機能を備え、あなたが安心して運用できる状態。

---

### 個人開発者への最後のアドバイス

*   **行き詰まったら休む**: 一人で開発していると、一つの問題で何時間も溶かすことがあります。そういう時は散歩に出る、寝るなどして、頭をリフレッシュするのが一番の近道です。
*   **コミュニティを頼る**: Inngest, Modal, SupabaseなどはDiscordやSlackコミュニティが活発です。ドキュメントで解決しない問題は、そこで質問すれば作者本人から回答がもらえることもあります。
*   **すべてを自作しない**: `shadcn/ui`のようなUIコンポーネントライブラリを積極的に使い、デザインにかかる時間を節約しましょう。あなたは「翻訳アプリ」を作るのであって、「UIコンポーネント」を作るのではありません。

このガイドは、巨大な山を登るための、安全で確実な登山ルートです。一歩ずつ、着実に景色が変わっていくのを楽しみながら、開発を進めてください。応援しています！